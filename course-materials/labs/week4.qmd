---
title: "Week 4: Lab"
subtitle: "EDS 223: Geospatial Analysis & Remote Sensing"
author: "Ruth Oliver"
date: last-modified
execute: 
  eval: true
format:
  html:
    toc: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| eval: true
#| echo: false
#| out-width: "30%"
#| fig-align: "center"
knitr::include_graphics("images/terra.png")
```

::: {.gray-text .center-text}
[terra](https://rspatial.github.io/terra/){target="_blank"}
:::

::: {.callout-note icon=true}
# Source Materials
The following materials are modified from [Chapters 3](https://geocompr.robinlovelace.net/attr.html), [4](https://geocompr.robinlovelace.net/spatial-operations.html), and [5](https://geocompr.robinlovelace.net/geometry-operations.html) of *Geocomputation with R* by Robin Lovelace.
:::



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Set Up

```{r install, include=TRUE, message=FALSE, warning=FALSE}
library(terra)
library(dplyr)
library(spData)
library(spDataLarge)
library(tmap)
#library(geodata)
```


## 2. Raster objects

Raster data represents continuous surfaces, as opposed to the discrete features represented in the vector data model. Here we'll learn how to create raster data objects from scratch and how to do basic data manipulations.

### Creating raster objects

The `{terra}` package represents raster objects using the `SpatRaster` class. The easiest way to create `SpatRaster` objects is to read them in using the `rast()` function. Raster objects can handle both continuous and categorical data.

We'll start with an example of two datasets for Zion National Park from the `spDataLarge` package:

- `srtm.tif`: remotely sensed elevation estimates (continous data)
- `nlcd.tif`: simplified version of the National Land Cover Database 2011 product (categorical data)

```{r}
# create raster objects
zion_elevation <- rast(system.file("raster/srtm.tif", package = "spDataLarge"))
zion_land <- rast(system.file("raster/nlcd.tif", package = "spDataLarge"))

# test class of raster object
class(zion_elevation)

```

```{r}
#| code-fold: true
#| message: false
map1 <- tm_shape(zion_elevation) +
  tm_raster(title = "Elevation (m)") +
  tm_layout(legend.outside = TRUE)

map2 <- tm_shape(zion_land) +
  tm_raster(title = "Land cover") +
  tm_layout(legend.outside = TRUE)

tmap_arrange(map1, map2, nrow = 1)
```

The `SpatRaster` class can also handle multiple "layers". Layers can store different variables for the same region in one object. This is similar to attributes (or columns) in `data.frames`. Later in the course when we discuss multispectral data, we'll learn more about why remotely-sensed data will often contain multiple "bands" or layers. 

As an example, we'll load a dataset from `spDataLarge` containing the four bands of the Landsat 8 image for Zion National Park

```{r}
landsat <- rast(system.file("raster/landsat.tif", package = "spDataLarge"))

nlyr(landsat) # test number of layers in raster object

tm_shape(landsat) +
  tm_raster()
```

We can subset layers using either the layer number or name:

```{r}
landsat3 <- subset(landsat, 3)
landsat4 <- subset(landsat, "landsat_4")
```

We can combine SpatRaster objects into one, using `c()`:

```{r}
landsat34 <- c(landsat3, landsat4)
```


## Summarizing Raster Objects

We can get info on raster values just by typing the name or using the summary function.

```{r include=TRUE}
summary(zion_elevation)
```

We can get global summaries, such as standard deviation.

```{r include=TRUE}
global(zion_elevation, sd)
```

Or we can use `freq()` to get the counts with categories.

```{r include=TRUE}
freq(zion_land)

hist(zion_land)
```
