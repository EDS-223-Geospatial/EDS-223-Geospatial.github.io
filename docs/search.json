[
  {
    "objectID": "course-materials/labs/week1.html",
    "href": "course-materials/labs/week1.html",
    "title": "Week 1 Lab",
    "section": "",
    "text": "Source Materials\n\n\n\nThe following materials are modified from the tmap book.\nIn this lab, we’ll explore the basics of map-making in R using the tmap package."
  },
  {
    "objectID": "course-materials/labs/week1.html#why-tmap",
    "href": "course-materials/labs/week1.html#why-tmap",
    "title": "Week 1 Lab",
    "section": "1. Why tmap?",
    "text": "1. Why tmap?\n\nThere are MANY ways to make maps in R, but tmap or “thematic maps” offers the most flexibility.\ntmap can handle vector and raster objects from the sf, sp, raster, and stars packages.\nThe syntax of tmap is based on ggplot2 and the Grammar of Graphics\ntmap supports static AND interactive maps (yay!)"
  },
  {
    "objectID": "course-materials/labs/week1.html#set-up",
    "href": "course-materials/labs/week1.html#set-up",
    "title": "Week 1 Lab",
    "section": "2. Set up",
    "text": "2. Set up\n\nFork and clone this repository to create a version controlled project for Week 1.\nCreate a Quarto doc\nInstall and load all necessary packages\n\n\ninstall.packages(\"sf\")\ninstall.packages(\"stars\")\ninstall.packages(\"tmap\")\n\n\nlibrary(sf) # for vector data (more soon!)\nlibrary(stars) # for raster data (more soon!)\nlibrary(tmap) # for static and interactive maps\nlibrary(here)"
  },
  {
    "objectID": "course-materials/labs/week1.html#specifying-spatial-data",
    "href": "course-materials/labs/week1.html#specifying-spatial-data",
    "title": "Week 1 Lab",
    "section": "3. Specifying spatial data",
    "text": "3. Specifying spatial data\nSimilar to plotting in ggplot2, in order to plot spatial data, at least two aspects need to be specified:\n\nthe spatial data object to plot (e.g. ggplot(data = ))\nand the plotting method (e.g. geom_points())\n\nLet’s load three spatial data objects to plot:\n\na raster (more on this next week!) of elevations of the world\na vector dataset (again, more soon!) of country boundaries\na vector dataset of locations of major cities\n\n\n# raster of global elevations\nworld_elevation &lt;- read_stars(here(\"data\",\"worldelevation.tif\"))\n\n# country boundaries\nworld_vector &lt;- read_sf(here(\"data\",\"worldvector.gpkg\"))\n\n# major cities\nworld_cities &lt;- read_sf(here(\"data\",\"worldcities.gpkg\"))\n\n\nShapes and layers\nIn tmap, the spatial object to plot needs to be defined within the function tm_shape(). This is analogous to defining the data frame to plot in ggplot2 (ggplot(data = )).\nLet’s start by plotting the countries of the world.\n\n# plotting a single spatial object\n\ntm_shape(world_vector) + # defines the spatial object to plot\n  tm_polygons() # defines how to plot the object\n\n\n\n\n\n\n\n\n\n\nShapes hierarchy\nSimilar to ggplot2, we can plot multiple datasets by adding layers. When multiple spatial objects are being plotted, each has to be defined in a separate tm_shape() call.\nNow let’s plot the following two spatial objects:\n\ncountries of the world\nmajor cities of the world\n\nIn the next section we’ll unpack the difference between tm_polygons() and tm_dots(), but for now let’s just pay attention to the syntax of how we plot multiple spatial objects. Each spatial object needs to be specified using tm_shape() followed by a function for how to plot it.\n\n# plotting two spatial objects\n\ntm_shape(world_vector) + # defines the FIRST spatial object to plot\n  tm_polygons() + # defines how to plot the FIRST object\ntm_shape(world_cities) + # defines the SECOND objet to plot\n  tm_dots() # defines how to plot the SECOND object\n\n\n\n\n\n\n\n\nSo far, we’ve only tried plotting vector data (more on what this means next week!), but one of the major advantages of tmap is that it allows us to plot vector and raster on the same map.\nLet’s try on example of this by adding information on global elevations to our previous map.\n\n# plotting vector and raster spatial objects\n\ntm_shape(world_elevation) + # plot global elevations\n  tm_raster() + # tm_raster for raster data\ntm_shape(world_vector) +\n  tm_borders() +\ntm_shape(world_cities) +\n  tm_dots() +\n  tm_text(\"name\")\n\nVariable(s) \"NA\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\n\n\nSimilar to ggplot2 the order of the “layers” matters! The order in which datasets are plotted defines how they are layered (think of this is as adding layers of paint). Spatial objects have extra features which additionally change this behavior: spatial extent and projection. When creating maps with tmap, whichever dataset is used in the first tm_shape() call sets the spatial extent and projection (more details next week!) for the entire map.\nFor example, if we swapped the order of tm_shape() calls in the previous example, we’d end up with a different map.\n\ntm_shape(world_cities) + # plot world_cities first\n  tm_dots() +\n  tm_text(\"name\") +\ntm_shape(world_elevation) +\n  tm_raster() +\ntm_shape(world_vector) +\n  tm_borders() \n\nVariable(s) \"NA\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\n\n\nSometimes this can present sticky issues! Imagine the case where we want to use the spatial extent and projection from the world_cities data, but want it plotted on top of the other datasets. We can do this by changing the main shape using the is.master argument.\n\ntm_shape(world_elevation) + \n  tm_raster() + \ntm_shape(world_vector) +\n  tm_borders() +\ntm_shape(world_cities, is.master = TRUE) + # plot world_cities last, but set as main shape\n  tm_dots() +\n  tm_text(\"name\")\n\nVariable(s) \"NA\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\n\n\n\n\nMap extent\nOne thing to consider when making maps is what area we want to show on the map – the spatial extent of our map. This isn’t an issue when we want to map all of our data (spatial extent of our data matches our desired map extent). But often our data will represent a larger region than what we want to map.\nWe have two options:\n\nprocess our data to create a new spatial object for exactly what we want to map (fine, but annoying)\nchange the extent of a map\n\ntmap has a few options for changing the map extent. The first is by defining a bounding box that specifies the minimum and maximum coordinates in the x and y directions that we want to represent. The values need to be in the units of the original data or we can create a bounding box using st_bbox().\nFor example, let’s restrict our previous map to just Europe using a set of min/max values.\n\ntm_shape(world_elevation, bbox = c(-15, 35, 45, 65)) + # add bounding box to restrict extent\n  tm_raster() + \ntm_shape(world_vector) +\n  tm_borders() \n\nVariable(s) \"NA\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\n\n\nWe can also restrict the extent of the map using the extent of a dataset. For example, we can restrict the map using the extent of the world_cities data.\n\ntm_shape(world_elevation, bbox = world_cities) + # bounding box = extent of world_cities\n  tm_raster() + \ntm_shape(world_vector) +\n  tm_borders() \n\nVariable(s) \"NA\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBonus Tip\n\n\n\n\n\nYou can also restrict the map extent using an OpenStreetMap tool called Nominatim to automatically generate minimum and maximum coordinates in the x and y directions based on the provided query.\n\ntm_shape(world_elevation, bbox = \"Europe\") + # query the region of Europe\n  tm_raster(palette = terrain.colors(8))"
  },
  {
    "objectID": "resources.html#r-programming",
    "href": "resources.html#r-programming",
    "title": "Resources",
    "section": "R Programming",
    "text": "R Programming\n\nTidyverse style guide\nTidy design principles\nr-spatial\nSpatial Statistics for Data Science: Theory and Practice with R. Paula Moraga, 2023."
  },
  {
    "objectID": "resources.html#coordinate-systems-and-projections",
    "href": "resources.html#coordinate-systems-and-projections",
    "title": "Resources",
    "section": "Coordinate Systems and Projections",
    "text": "Coordinate Systems and Projections\n\nGeographic vs projected coordinate systems (Esri)\nCoordinate Reference System and Spatial Projection (Earth Lab, CU Boulder)\nGuide to map projections (Axis Maps)\nChoosing a projection (Penn State)\nDiscover coordinate systems"
  },
  {
    "objectID": "resources.html#mapmaking",
    "href": "resources.html#mapmaking",
    "title": "Resources",
    "section": "Mapmaking",
    "text": "Mapmaking\n\nColor palette finder with paletteer\nColorBrewer 2.0\nIntro to Color Visualization (NASA)\nGIS icons\nGuide to common errors in map production (Journal of Maps)"
  },
  {
    "objectID": "course-materials/week8.html",
    "href": "course-materials/week8.html",
    "title": "Remote sensing of vegetation",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nSpectral properties of vegetation (leaf, canopy, and landscape)\n\n\n Lab\nNDVI and phenology\n\n\n Discussion\ndescription"
  },
  {
    "objectID": "course-materials/week8.html#class-materials",
    "href": "course-materials/week8.html#class-materials",
    "title": "Remote sensing of vegetation",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nSpectral properties of vegetation (leaf, canopy, and landscape)\n\n\n Lab\nNDVI and phenology\n\n\n Discussion\ndescription"
  },
  {
    "objectID": "course-materials/week8.html#assignment-reminders",
    "href": "course-materials/week8.html#assignment-reminders",
    "title": "Remote sensing of vegetation",
    "section": " Assignment Reminders",
    "text": "Assignment Reminders\n\n\n\nAssignment Type\nAssignment Title\nDate Assigned\nDate Due\n\n\n\n\nEOC\nEnd-of-class survey (week 1)\nMon 01/08/2024\nMon 01/08/2024, 11:55pm PT\n\n\nSR\nSelf reflection (SR #1)\nMon 01/08/2024\nSat 01/13/2024, 11:59pm PT\n\n\nHW\nHomework Assignment #1\nMon 01/08/2024\nSat 01/20/2024, 11:59pm PT"
  },
  {
    "objectID": "course-materials/week8.html#background-reading",
    "href": "course-materials/week8.html#background-reading",
    "title": "Remote sensing of vegetation",
    "section": " Background Reading",
    "text": "Background Reading\n\nRemote Sensing of the Environment, Chapter 10"
  },
  {
    "objectID": "course-materials/week5.html",
    "href": "course-materials/week5.html",
    "title": "Intro to remote sensing & electromagnetism",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nFundamentals of electromagnetic radiation\n\n\n Lab\nRaster geometry operations: local, focal, and zonal\n\n\n Discussion\nPractice with raster geomerty operations"
  },
  {
    "objectID": "course-materials/week5.html#class-materials",
    "href": "course-materials/week5.html#class-materials",
    "title": "Intro to remote sensing & electromagnetism",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nFundamentals of electromagnetic radiation\n\n\n Lab\nRaster geometry operations: local, focal, and zonal\n\n\n Discussion\nPractice with raster geomerty operations"
  },
  {
    "objectID": "course-materials/week5.html#assignment-reminders",
    "href": "course-materials/week5.html#assignment-reminders",
    "title": "Intro to remote sensing & electromagnetism",
    "section": " Assignment Reminders",
    "text": "Assignment Reminders\n\n\n\nAssignment Type\nAssignment Title\nDate Assigned\nDate Due\n\n\n\n\nEOC\nEnd-of-class survey (week 1)\nMon 01/08/2024\nMon 01/08/2024, 11:55pm PT\n\n\nSR\nSelf reflection (SR #1)\nMon 01/08/2024\nSat 01/13/2024, 11:59pm PT\n\n\nHW\nHomework Assignment #1\nMon 01/08/2024\nSat 01/20/2024, 11:59pm PT"
  },
  {
    "objectID": "course-materials/week5.html#background-reading",
    "href": "course-materials/week5.html#background-reading",
    "title": "Intro to remote sensing & electromagnetism",
    "section": " Background Reading",
    "text": "Background Reading\n\nRemote Sensing of the Environment, Chapter 1\nRemote Sensing of the Environment, Chapter 2"
  },
  {
    "objectID": "course-materials/week3.html",
    "href": "course-materials/week3.html",
    "title": "Spatial and geometry operations with vector data",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nIntro to basic spatial data and geometry operations with vector data\n\n\n Lab\nSpatial joins, topological relationships, and distance relationships\n\n\n Discussion\nPractice with vector operations"
  },
  {
    "objectID": "course-materials/week3.html#class-materials",
    "href": "course-materials/week3.html#class-materials",
    "title": "Spatial and geometry operations with vector data",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nIntro to basic spatial data and geometry operations with vector data\n\n\n Lab\nSpatial joins, topological relationships, and distance relationships\n\n\n Discussion\nPractice with vector operations"
  },
  {
    "objectID": "course-materials/week3.html#assignment-reminders",
    "href": "course-materials/week3.html#assignment-reminders",
    "title": "Spatial and geometry operations with vector data",
    "section": " Assignment Reminders",
    "text": "Assignment Reminders\n\n\n\nAssignment Type\nAssignment Title\nDate Assigned\nDate Due\n\n\n\n\nEOC\nEnd-of-class survey (week 1)\nMon 01/08/2024\nMon 01/08/2024, 11:55pm PT\n\n\nSR\nSelf reflection (SR #1)\nMon 01/08/2024\nSat 01/13/2024, 11:59pm PT\n\n\nHW\nHomework Assignment #1\nMon 01/08/2024\nSat 01/20/2024, 11:59pm PT"
  },
  {
    "objectID": "course-materials/week3.html#background-reading",
    "href": "course-materials/week3.html#background-reading",
    "title": "Spatial and geometry operations with vector data",
    "section": "Background Reading",
    "text": "Background Reading\n\nGeocomputation with R, Chapter 4\nGeocomputation with R, Chapter 5\nGIS Fundamentals, Chapter 9 Part 1\nDouglas–Peucker Algorithm (Cartography Playground)\nLine Simplification with Visvalingam–Whyatt Algorithm (Mike Bostok)"
  },
  {
    "objectID": "course-materials/week3.html#technical-background",
    "href": "course-materials/week3.html#technical-background",
    "title": "Spatial and geometry operations with vector data",
    "section": "Technical Background",
    "text": "Technical Background\n\nsf overview\nsf cheatsheet\nIntroduction to sf and stars"
  },
  {
    "objectID": "course-materials/week10.html",
    "href": "course-materials/week10.html",
    "title": "Intro to active remote sensing",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nFundamentals of active remote sensing: LiDAR and RADAR\n\n\n Lab\nValidating LiDAR tree height estimates\n\n\n Discussion\ndescription"
  },
  {
    "objectID": "course-materials/week10.html#class-materials",
    "href": "course-materials/week10.html#class-materials",
    "title": "Intro to active remote sensing",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nFundamentals of active remote sensing: LiDAR and RADAR\n\n\n Lab\nValidating LiDAR tree height estimates\n\n\n Discussion\ndescription"
  },
  {
    "objectID": "course-materials/week10.html#assignment-reminders",
    "href": "course-materials/week10.html#assignment-reminders",
    "title": "Intro to active remote sensing",
    "section": " Assignment Reminders",
    "text": "Assignment Reminders\n\n\n\nAssignment Type\nAssignment Title\nDate Assigned\nDate Due\n\n\n\n\nEOC\nEnd-of-class survey (week 1)\nMon 01/08/2024\nMon 01/08/2024, 11:55pm PT\n\n\nSR\nSelf reflection (SR #1)\nMon 01/08/2024\nSat 01/13/2024, 11:59pm PT\n\n\nHW\nHomework Assignment #1\nMon 01/08/2024\nSat 01/20/2024, 11:59pm PT"
  },
  {
    "objectID": "course-materials/week10.html#background-reading",
    "href": "course-materials/week10.html#background-reading",
    "title": "Intro to active remote sensing",
    "section": " Background Reading",
    "text": "Background Reading\n\nRemote Sensing of the Environment, Chapter 9\nIntroduction to Interpreting Digital RADAR Images\nIntroduction to Light Detection and Ranging (Lidar) Remote Sensing Data (Earth Lab, CU Boulder)\nWhat is Synthetic Aperture Radar? (NASA)\nGet To Know SAR: Polarimetry (NASA)"
  },
  {
    "objectID": "course-materials/week10.html#additional-resources",
    "href": "course-materials/week10.html#additional-resources",
    "title": "Intro to active remote sensing",
    "section": " Additional Resources",
    "text": "Additional Resources\n\nExplore Lidar Points in Plas.io (Earth Lab, CU Boulder)"
  },
  {
    "objectID": "course-materials/template.html",
    "href": "course-materials/template.html",
    "title": "template {add topic}",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\ndescription\n\n\n Lab\ndescription\n\n\n Discussion\ndescription"
  },
  {
    "objectID": "course-materials/template.html#class-materials",
    "href": "course-materials/template.html#class-materials",
    "title": "template {add topic}",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\ndescription\n\n\n Lab\ndescription\n\n\n Discussion\ndescription"
  },
  {
    "objectID": "course-materials/template.html#assignment-reminders",
    "href": "course-materials/template.html#assignment-reminders",
    "title": "template {add topic}",
    "section": " Assignment Reminders",
    "text": "Assignment Reminders\n\n\n\nAssignment Type\nAssignment Title\nDate Assigned\nDate Due\n\n\n\n\nEOC\nEnd-of-class survey (week 1)\nMon 01/08/2024\nMon 01/08/2024, 11:55pm PT\n\n\nSR\nSelf reflection (SR #1)\nMon 01/08/2024\nSat 01/13/2024, 11:59pm PT\n\n\nHW\nHomework Assignment #1\nMon 01/08/2024\nSat 01/20/2024, 11:59pm PT"
  },
  {
    "objectID": "course-materials/template.html#background-reading",
    "href": "course-materials/template.html#background-reading",
    "title": "template {add topic}",
    "section": " Background Reading",
    "text": "Background Reading"
  },
  {
    "objectID": "course-materials/template.html#additional-resources",
    "href": "course-materials/template.html#additional-resources",
    "title": "template {add topic}",
    "section": " Additional Resources",
    "text": "Additional Resources"
  },
  {
    "objectID": "course-materials/labs/week8.html",
    "href": "course-materials/labs/week8.html",
    "title": "Week 8: Lab",
    "section": "",
    "text": "Phenology is the timing of life history events. Important phenological events for plants involve the growth of leaves, flowering, and senescence (death of leaves). Plants species adapt the timing of these events to local climate conditions to ensure successful reproduction. Subsequently, animal species often adapt their phenology to take advantage of food availability. As the climate shifts this synchronization is being thrown out of whack. Shifts in phenology are therefore a common yardstick of understanding how and if ecosystems are adjusting to climate change.\nPlant species may employ the following phenological strategies:\nThis lab is based on a materials developed by Chris Kibler."
  },
  {
    "objectID": "course-materials/labs/week8.html#task",
    "href": "course-materials/labs/week8.html#task",
    "title": "Week 8: Lab",
    "section": "Task",
    "text": "Task\nIn this lab we are analyzing plant phenology near the Santa Clara River which flows from Santa Clarita to Ventura. We will investigate the phenology of the following plant communities:\n\nRiparian forests: grow along the river, dominated by winter deciduous cottonwood and willow trees\nGrasslands: grow in openspaces, dominated by drought deciduous grasses\nChaparral shrublands: grow in more arid habitats, dominated by evergreen shrubs\n\nTo investigate the phenology of these plant communities we will a time series of Landsat imagery and polygons identifying the locations of study sites within each plant community.\nOur goals in this lab are:\n\nConvert spectral reflectance into a measure of vegetation productivity (NDVI)\nCalculate NDVI throughout the year\nSummarize NDVI values within vegetation communities\nVisualize changes in NDVI within vegetation communities"
  },
  {
    "objectID": "course-materials/labs/week8.html#data",
    "href": "course-materials/labs/week8.html#data",
    "title": "Week 8: Lab",
    "section": "Data",
    "text": "Data\nLandsat’s Operational Land Imager (OLI)\n\n8 pre-processed scenes\n\nLevel 2 surface reflectance products\nErroneous values set to NA\nScale factor set to 100\nBands 2-7\nDates in filenname\n\n\nStudy sites\n\nPolygons representing sites\n\nstudy_site: character string with plant type"
  },
  {
    "objectID": "course-materials/labs/week8.html#prerequisites",
    "href": "course-materials/labs/week8.html#prerequisites",
    "title": "Week 8: Lab",
    "section": "Prerequisites",
    "text": "Prerequisites\nLet’s load all necessary packages:\n\nlibrary(terra)\nlibrary(sf)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(here)\nlibrary(tmap)\nlibrary(cowplot)"
  },
  {
    "objectID": "course-materials/labs/week8.html#create-ndvi-function",
    "href": "course-materials/labs/week8.html#create-ndvi-function",
    "title": "Week 8: Lab",
    "section": "Create NDVI Function",
    "text": "Create NDVI Function\nLet’s start by defining a function to compute the NDVI.\n\nNDVI computes the difference in reflectance in the near infrared and red bands, normalized by their sum.\n\n\nndvi_fun &lt;- function(nir, red){\n  (nir - red) / (nir + red)\n}"
  },
  {
    "objectID": "course-materials/labs/week8.html#compute-ndvi-for-a-single-scene",
    "href": "course-materials/labs/week8.html#compute-ndvi-for-a-single-scene",
    "title": "Week 8: Lab",
    "section": "Compute NDVI for a Single Scene",
    "text": "Compute NDVI for a Single Scene\nWe have 8 scenes collected by Landsat’s OLI sensor on 8 different days throughout the year.\nLet’s start by loading in the first scene collected on June 12, 2018:\n\nlandsat_20180612 &lt;- rast(here(\"course-materials\", \"data\", \"week8\", \"landsat_20180612.tif\"))\nlandsat_20180612\n\nNow let’s update the names of the layers to match the spectral bands they correspond to:\n\nnames(landsat_20180612) &lt;- c(\"blue\", \"green\", \"red\", \"NIR\", \"SWIR1\", \"SWIR2\")\nlandsat_20180612\n\nNow we can apply the NDVI function we created to compute NDVI for this scene using the lapp() function.\n\nThe lapp() function applies a function to each cell using layers as arguments.\nTherefore, we need to tell lapp() which layers (or bands) to pass into the function.\n\nThe NIR band is the 4th layer and the red band is the 3rd layer in our raster. In this case, because we defined the NIR band as the first argument and the red band as the second argument in our function, we tell lapp() to use the 4th layer first and 3rd layer second.\n\nndvi_20180612 &lt;- lapp(landsat_20180612[[c(4, 3)]], fun = ndvi_fun)\nndvi_20180612"
  },
  {
    "objectID": "course-materials/labs/week8.html#attempt-1-compute-ndvi-for-all-scences",
    "href": "course-materials/labs/week8.html#attempt-1-compute-ndvi-for-all-scences",
    "title": "Week 8: Lab",
    "section": "Attempt 1: Compute NDVI for All Scences",
    "text": "Attempt 1: Compute NDVI for All Scences\nNow we want to repeat the same operations for all 8 scenes. Below is a possible solution, but it’s pretty clunky.\nLet’s load each layer:\n\nlandsat_20180612 &lt;-rast(here(\"course-materials\", \"data\", \"week8\", \"landsat_20180612.tif\"))\nlandsat_20180815 &lt;- rast(here(\"course-materials\", \"data\", \"week8\", \"landsat_20180815.tif\"))\nlandsat_20181018 &lt;- rast(here(\"course-materials\", \"data\", \"week8\", \"landsat_20181018.tif\"))\nlandsat_20181103 &lt;- rast(here(\"course-materials\", \"data\", \"week8\", \"landsat_20181103.tif\"))\nlandsat_20190122 &lt;- rast(here(\"course-materials\", \"data\", \"week8\", \"landsat_20190122.tif\"))\nlandsat_20190223 &lt;- rast(here(\"course-materials\", \"data\", \"week8\", \"landsat_20190223.tif\"))\nlandsat_20190412 &lt;- rast(here(\"course-materials\", \"data\", \"week8\", \"landsat_20190412.tif\"))\nlandsat_20190701 &lt;- rast(here(\"course-materials\", \"data\", \"week8\", \"landsat_20190701.tif\"))\n\nAnd rename each layer:\n\nnames(landsat_20180612) &lt;- c(\"blue\", \"green\", \"red\", \"NIR\", \"SWIR1\", \"SWIR2\")\nnames(landsat_20180815) &lt;- c(\"blue\", \"green\", \"red\", \"NIR\", \"SWIR1\", \"SWIR2\")\nnames(landsat_20181018) &lt;- c(\"blue\", \"green\", \"red\", \"NIR\", \"SWIR1\", \"SWIR2\")\nnames(landsat_20181103) &lt;- c(\"blue\", \"green\", \"red\", \"NIR\", \"SWIR1\", \"SWIR2\")\nnames(landsat_20190122) &lt;- c(\"blue\", \"green\", \"red\", \"NIR\", \"SWIR1\", \"SWIR2\")\nnames(landsat_20190223) &lt;- c(\"blue\", \"green\", \"red\", \"NIR\", \"SWIR1\", \"SWIR2\")\nnames(landsat_20190412) &lt;- c(\"blue\", \"green\", \"red\", \"NIR\", \"SWIR1\", \"SWIR2\")\nnames(landsat_20190701) &lt;- c(\"blue\", \"green\", \"red\", \"NIR\", \"SWIR1\", \"SWIR2\")\n\nNext, compute NDVI for each layer:\n\nndvi_20180612 &lt;- lapp(landsat_20180612[[c(4, 3)]], fun = ndvi_fun)\nndvi_20180815 &lt;- lapp(landsat_20180815[[c(4, 3)]], fun = ndvi_fun)\nndvi_20181018 &lt;- lapp(landsat_20181018[[c(4, 3)]], fun = ndvi_fun)\nndvi_20181103 &lt;- lapp(landsat_20181103[[c(4, 3)]], fun = ndvi_fun)\nndvi_20190122 &lt;- lapp(landsat_20190122[[c(4, 3)]], fun = ndvi_fun)\nndvi_20190223 &lt;- lapp(landsat_20190223[[c(4, 3)]], fun = ndvi_fun)\nndvi_20190412 &lt;- lapp(landsat_20190412[[c(4, 3)]], fun = ndvi_fun)\nndvi_20190701 &lt;- lapp(landsat_20190701[[c(4, 3)]], fun = ndvi_fun)\n\nLet’s combine NDVI layers into a single raster stack.\n\nall_ndvi &lt;- c(ndvi_20180612, ndvi_20180815, ndvi_20181018, ndvi_20181103, ndvi_20190122, ndvi_20190223, ndvi_20190412, ndvi_20190701)\n\nNow, update the names of each layer to match the date of each image:\n\nnames(all_ndvi) &lt;- c(\"2018-06-12\", \"2018-08-15\", \"2018-10-18\", \"2018-11-03\", \"2019-01-22\", \"2019-02-23\", \"2019-04-12\", \"2019-07-01\")"
  },
  {
    "objectID": "course-materials/labs/week8.html#attempt-2-compute-ndvi-for-all-scenes",
    "href": "course-materials/labs/week8.html#attempt-2-compute-ndvi-for-all-scenes",
    "title": "Week 8: Lab",
    "section": "Attempt 2: Compute NDVI for All Scenes",
    "text": "Attempt 2: Compute NDVI for All Scenes\nThe first attempt was pretty clunky and required a lot of copy/pasting. Because we’re performing the same operations over and over again, this is a good opportunity to generalize our workflow into a function!\nLet’s start over and see how we could do this more efficiently.\nWe’ll clear our environment and redefine our function for NDVI:\n\nndvi_fun &lt;- function(nir, red){\n  (nir - red) / (nir + red)\n}\n\nNext, let’s first sketch out what operations we want to perform so we can figure out what our function needs:\n\n# Note: this code is not meant to run! \n# We're just outlining the function we want to create\n\ncreate_ndvi_layer &lt;- function(){\n  # Read scene\n  landsat &lt;- rast(file)\n  # Rename layer\n  names(landsat) &lt;- c(\"blue\", \"green\", \"red\", \"NIR\", \"SWIR1\", \"SWIR2\")\n  # Compute NDVI\n  ndvi &lt;- lapp(landsat[[c(4, 3)]], fun = ndvi_fun)\n}\n\n# What do we notice as what we need to pass into our function?\n\nWe want a list of the scenes so that we can tell our function to compute NDVI for each. To do that we look in our data folder for the relevant file.\n\nAsk for the names of all the files in the week8 folder\nSet the “pattern” option to return the names that end in .tif (\n\n.tif is the file extension for the landsat scenes\n\nSet the “full.names” option returns the full file path for each scene\n\n\nfiles &lt;- list.files(\n  here(\"course-materials\", \"data\", \"week8\"), pattern = \"*.tif\", \n  full.names = TRUE)\n\nNow let’s update our function to work with list of file names we created:\n\nPass function a number that will correspond to the index in the list of file names\n\n\ncreate_ndvi_layer &lt;- function(i){\n  landsat &lt;- rast(files[i])\n  names(landsat) &lt;- c(\"blue\", \"green\", \"red\", \"NIR\", \"SWIR1\", \"SWIR2\")\n  ndvi &lt;- lapp(landsat[[c(4, 3)]], fun = ndvi_fun)\n}\n\nLet’s test our function by asking it to read in the first file:\n\ntest &lt;- create_ndvi_layer(1)\n\nNow we can use our function to create a NDVI layer for each scene and stack them into a single rasterstack. And then update layer names to match date:\n\nall_ndvi &lt;- c(create_ndvi_layer(1), create_ndvi_layer(2), create_ndvi_layer(3), create_ndvi_layer(4), create_ndvi_layer(5), create_ndvi_layer(6), create_ndvi_layer(7), create_ndvi_layer(8))\n\nnames(all_ndvi) &lt;- c(\"2018-06-12\", \"2018-08-15\", \"2018-10-18\", \"2018-11-03\", \"2019-01-22\", \"2019-02-23\", \"2019-04-12\", \"2019-07-01\")"
  },
  {
    "objectID": "course-materials/labs/week8.html#compare-ndvi-across-vegetation-communities",
    "href": "course-materials/labs/week8.html#compare-ndvi-across-vegetation-communities",
    "title": "Week 8: Lab",
    "section": "Compare NDVI Across Vegetation Communities",
    "text": "Compare NDVI Across Vegetation Communities\nNow that we have computed NDVI for each of our scenes (days) we want to compare changes in NDVI values across different vegetation communities.\nFirst, we’ll read in a shapefile of study sites:\n\nsites &lt;- st_read(here(\"course-materials\", \"data\",\"week8\",\"study_sites.shp\"))\n\nAnd plot study sites on a single NDVI layer:\n\ntm_shape(all_ndvi[[1]]) +\n  tm_raster() +\n  tm_shape(sites) +\n  tm_polygons()\n\n\nExtract NDVI at Study Sites\nHere, we find the average NDVI within each study site. The output of extract is a data frame with rows that match the study site dataset, so we bind the results to the original dataset.\n\nsites_ndvi &lt;- terra::extract(all_ndvi, sites, fun = \"mean\")\n\nsites_annotated &lt;- cbind(sites, sites_ndvi)\n\nWe’re done! Except our data is very untidy… Let’s tidy it up!\n\nConvert to data frame\nTurn from wide to long format\nTurn layer names into date format\n\n\nsites_clean &lt;- sites_annotated %&gt;%\n  st_drop_geometry() %&gt;%\n  select(-ID) %&gt;%\n  pivot_longer(!study_site) %&gt;%\n  rename(\"NDVI\" = value) %&gt;%\n  mutate(\"year\" = str_sub(name, 2, 5),\n         \"month\" = str_sub(name, 7, 8),\n         \"day\" = str_sub(name, -2, -1)) %&gt;%\n  unite(\"date\", 4:6, sep = \"-\") %&gt;%\n  mutate(\"date\" = lubridate::as_date(date))"
  },
  {
    "objectID": "course-materials/labs/week8.html#plot-results",
    "href": "course-materials/labs/week8.html#plot-results",
    "title": "Week 8: Lab",
    "section": "Plot Results",
    "text": "Plot Results\nLet’s plot the results:\n\nggplot(sites_clean,\n       aes(x = date, y = NDVI,\n           group = study_site, col = study_site)) +\n  scale_color_manual(values = c(\"#EAAC8B\", \"#315C2B\", \"#315C2B\", \"#315C2B\",\"#9EA93F\")) +\n  geom_line() +\n  theme_minimal() +\n  labs(x = \"\", y = \"Normalized Difference Vegetation Index (NDVI)\", col = \"Vegetation type\",\n       title = \"Seasonal cycles of vegetation productivity\")"
  },
  {
    "objectID": "course-materials/labs/week3.html",
    "href": "course-materials/labs/week3.html",
    "title": "Week 3: Lab",
    "section": "",
    "text": "In this lab, we’ll explore the basics of spatial and geometry operations on vector data in R using the sf package. The following materials are modified from Chapter 4 and Chapter 5 of Geocomputation with R by Robin Lovelace."
  },
  {
    "objectID": "course-materials/labs/week3.html#set-up",
    "href": "course-materials/labs/week3.html#set-up",
    "title": "Week 3: Lab",
    "section": "Set Up",
    "text": "Set Up\nLet’s load all necessary packages:\n\nlibrary(sf)\nlibrary(tmap)\nlibrary(tidyverse)\nlibrary(rmapshaper)\nlibrary(smoothr)\nlibrary(spData)"
  },
  {
    "objectID": "course-materials/labs/week3.html#spatial-subsetting",
    "href": "course-materials/labs/week3.html#spatial-subsetting",
    "title": "Week 3: Lab",
    "section": "Spatial Subsetting",
    "text": "Spatial Subsetting\nSpatial subsetting is the process of converting a spatial object into a new object containing only the features that relate in space to another object. This is analogous the attribute subsetting that we covered last week. There are many ways to spatially subset in R, so we will explore a few.\nLet’s start by going back to the New Zealand datasets and find all the high points in the state of Canterbury.\n\ncanterbury &lt;- nz %&gt;%\n  filter(Name == \"Canterbury\")\n\n# subsets nz_heights to just the features that intersect Canterbury\nc_height &lt;- nz_height[canterbury, ]\n\ntm_shape(nz) +\n  tm_polygons() +\n  tm_shape(nz_height) +\n  tm_dots(fill = \"red\")\n\ntm_shape(nz) +\n  tm_polygons() +\n  tm_shape(canterbury) +\n  tm_polygons(fill = \"blue\") +\n  tm_shape(c_height) +\n  tm_dots(fill = \"red\")\n\nThe default is to subset to features that intersect, but we can use other operations, including finding features that do not intersect.\n\noutside_height &lt;- nz_height[canterbury, , op = st_disjoint]\n\ntm_shape(nz) +\n  tm_polygons() +\n  tm_shape(canterbury) +\n  tm_polygons(fill = \"blue\") +\n  tm_shape(outside_height) +\n  tm_dots(fill = \"red\")\n\nWe can perform the same operations using topological operators. These operators return matrices testing the relationship between features.\n\nsel_sgbp &lt;- st_intersects(x = nz_height, y = canterbury)\n\nsel_logical &lt;- lengths(sel_sgbp) &gt; 0\n\nc_height2 &lt;- nz_height[sel_logical, ]\n\ntm_shape(nz) +\n  tm_polygons() +\n  tm_shape(canterbury) +\n  tm_polygons(fill = \"blue\") +\n  tm_shape(c_height2) +\n  tm_dots(fill = \"red\")\n\nWe can also use the st_filter function in sf:\n\nc_height3 &lt;- nz_height %&gt;%\n  st_filter(y = canterbury, .predicate = st_intersects)\n\ntm_shape(nz) +\n  tm_polygons() +\n  tm_shape(canterbury) +\n  tm_polygons(fill = \"blue\") +\n  tm_shape(c_height3) +\n  tm_dots(fill = \"red\")\n\nWe can change the predicate option to test subset to features that don’t intersect:\n\noutside_height2 &lt;- nz_height %&gt;%\n  st_filter(y = canterbury, .predicate = st_disjoint)\n\ntm_shape(nz) +\n  tm_polygons() +\n  tm_shape(canterbury) +\n  tm_polygons(fill = \"blue\") +\n  tm_shape(outside_height2) +\n  tm_dots(fill = \"red\")"
  },
  {
    "objectID": "course-materials/labs/week3.html#buffers",
    "href": "course-materials/labs/week3.html#buffers",
    "title": "Week 3: Lab",
    "section": "Buffers",
    "text": "Buffers\nBuffers create polygons representing a set distance from a feature.\n\nseine_buffer &lt;- st_buffer(seine, dist = 5000)\n\ntm_shape(seine_buffer) +\n  tm_polygons()"
  },
  {
    "objectID": "course-materials/labs/week3.html#unions",
    "href": "course-materials/labs/week3.html#unions",
    "title": "Week 3: Lab",
    "section": "Unions",
    "text": "Unions\nAs we saw in the last lab, we can spatially aggregate without explicitly asking R to do so.\n\nworld %&gt;%\n  group_by(continent) %&gt;%\n  summarize(population = sum(pop, na.rm = TRUE))\n\nWhat is going on here? Behind the scenes, summarize() is using st_union() to dissolve the boundaries.\n\nus_west &lt;- us_states %&gt;%\n  filter(REGION == \"West\")\n\nus_west_union &lt;- st_union(us_west)\n\ntm_shape(us_west_union) +\n  tm_polygons()\n\nst_union() can also take 2 geometries and unite them.\n\ntexas &lt;-  us_states %&gt;%\n  filter(NAME == \"Texas\")\n\ntexas_union = st_union(us_west_union, texas)\n\ntm_shape(texas_union) +\n  tm_polygons()"
  },
  {
    "objectID": "course-materials/labs/week3.html#spatial-joining",
    "href": "course-materials/labs/week3.html#spatial-joining",
    "title": "Week 3: Lab",
    "section": "Spatial Joining",
    "text": "Spatial Joining\nWhere attribute joining depends on both data sets sharing a ‘key’ variable, spatial joining uses the same concept but depends on spatial relationships between data sets.\nLet’s test this out by creating 50 points randomly distributed across the world and finding out what countries they call in.\n\nset.seed(2018)\nbb &lt;- st_bbox(world)\n\nrandom_df &lt;- data.frame(\n  x = runif(n = 10, min = bb[1], max = bb[3]),\n  y = runif(n = 10, min = bb[2], max = bb[4])\n)\n\nrandom_points &lt;- random_df %&gt;%\n  st_as_sf(coords = c(\"x\", \"y\")) %&gt;%\n  st_set_crs(\"EPSG:4326\")\n\ntm_shape(world) +\n  tm_fill() +\n  tm_shape(random_points) +\n  tm_dots(fill = \"red\")\n\nLet’s first use spatial subsetting to find just the countries that contain random points.\n\nworld_random &lt;- world[random_points, ]\n\ntm_shape(world) +\n  tm_fill() +\n  tm_shape(world_random) +\n  tm_fill(fill = \"red\")\n\nNow let’s perform a spatial join to add the info from each country that a point falls into onto the point dataset.\n\nrandom_joined  &lt;- st_join(random_points, world)\n\ntm_shape(world) +\n  tm_fill() +\n  tm_shape(random_joined) +\n  tm_dots(fill = \"name_long\")\n\nBy default, st_join performs a left join. We change this and instead perform an inner join.\n\nrandom_joined_inner &lt;- st_join(random_points, world, left = FALSE)"
  },
  {
    "objectID": "course-materials/labs/week3.html#non-overlapping-joins",
    "href": "course-materials/labs/week3.html#non-overlapping-joins",
    "title": "Week 3: Lab",
    "section": "Non-Overlapping Joins",
    "text": "Non-Overlapping Joins\nSometimes we might want join geographic datasets that are strongly related, but do not have overlapping geometries. To demonstrate this, let’s look at data on cycle hire points in London.\n\ntmap_mode(\"view\")\n\ntm_shape(cycle_hire) +\n  tm_dots(col = \"blue\", alpha = 0.5) +\n  tm_shape(cycle_hire_osm) +\n  tm_dots(col = \"red\", alpha = 0.5)\n\n We can check if any of these points overlap.\n\nany(st_touches(cycle_hire, cycle_hire_osm, sparse = FALSE))\n\nLet’s say we need to join the ‘capacity’ variable in cycle_hire_osm onto the official ‘target’ data in cycle_hire. The simplest method is using the topological operator st_is_within_distance().\n\nsel &lt;- st_is_within_distance(cycle_hire, cycle_hire_osm, dist = 20)\n\nsummary(lengths(sel) &gt; 0) #summarizes the number of points within 20 meters\n\nNow, we’d like to add the values from cycle_hire_osm onto the cycle_hire points.\n\nz &lt;- st_join(cycle_hire, cycle_hire_osm, st_is_within_distance, dist = 20)\n\nnrow(cycle_hire)\n\nnrow(z)\n\nNote: the number of rows of the join is larger than the number of rows in the original dataset. Why? Because some points in ‘cycle_hire’ were within 20 meters of multiple points in ‘cycle_hire_osm’. If we wanted to aggregate so we have just one value per original point, we can use the aggregation methods from last week.\n\nz &lt;- z %&gt;%\n  group_by(id) %&gt;%\n  summarise(capacity = mean(capacity))"
  },
  {
    "objectID": "course-materials/labs/week3.html#spatial-aggregation",
    "href": "course-materials/labs/week3.html#spatial-aggregation",
    "title": "Week 3: Lab",
    "section": "Spatial Aggregation",
    "text": "Spatial Aggregation\nSimilar to attribute data aggregation, spatial data aggregation condenses data (we end up with fewer rows than we started with).\nLet’s say we wanted to find the average height of high point in each region of New Zealand. We could use the aggregate() function in base R.\n\nnz_agg &lt;- aggregate(x = nz_height, by = nz, FUN = mean)\n\nThe result of this is an object with the same geometries as the aggregating feature data set (in this case ‘nz’).\n\nnz_agg\n\nWe could also use a sf/dplyr approach.\n\nnz_agg &lt;- st_join(nz, nz_height) %&gt;%\n  group_by(Name) %&gt;%\n  summarise(elevation = mean(elevation, na.rm = TRUE))\n\nnz_agg"
  },
  {
    "objectID": "course-materials/labs/week3.html#joining-incongruent-layers",
    "href": "course-materials/labs/week3.html#joining-incongruent-layers",
    "title": "Week 3: Lab",
    "section": "Joining Incongruent Layers",
    "text": "Joining Incongruent Layers\nWe might want to aggregate data to geometries that are not congruent (i.e. their boundaries don’t line up). This causes issues when we think about how to summarize associated values.\n\n# head(incongruent)\n# head(aggregating_zones)\n\ntm_shape(incongruent) +\n  tm_polygons() +\n  tm_shape(aggregating_zones) +\n  tm_borders(col = \"red\")\n\n The simplest method for dealing with this is using area weighted spatial interpolation which transfers values from the ‘incongruent’ object to a new column in ‘aggregating_zones’ in proportion with the area of overlap.\n\niv &lt;- incongruent[\"value\"]\nagg_aw &lt;- st_interpolate_aw(iv, aggregating_zones, extensive = TRUE)\n\ntm_shape(agg_aw) +\n  tm_fill(fill = \"value\")"
  },
  {
    "objectID": "course-materials/labs/week3.html#centroids",
    "href": "course-materials/labs/week3.html#centroids",
    "title": "Week 3: Lab",
    "section": "Centroids",
    "text": "Centroids\nCentroids identify the center of a spatial feature. Similar to taking an average, there are many ways to compute a centroid. The most common is the geographic centroid.\n\nnz_centroid &lt;- st_centroid(nz)\n\ntm_shape(nz) +\n  tm_fill() +\n  tm_shape(nz_centroid) +\n  tm_dots()\n\n Sometimes centroids fall outside of the boundaries of the objects they were created from. In the case where we need them to fall inside of the feature, we can use point on surface methods.\n\nnz_pos &lt;- st_point_on_surface(nz)\n\ntm_shape(nz) +\n  tm_fill() +\n  tm_shape(nz_centroid) +\n  tm_dots() +\n  tm_shape(nz_pos) +\n  tm_dots(fill = \"red\")"
  },
  {
    "objectID": "course-materials/labs/week3.html#distance-relationships",
    "href": "course-materials/labs/week3.html#distance-relationships",
    "title": "Week 3: Lab",
    "section": "Distance Relationships",
    "text": "Distance Relationships\nWhile topological relationships are binary (features either intersect or don’t), distance relationships are continuous.\nFind the distance between the highest point in NZ and the centroid of the Canterbury region:\n\nnz_highest &lt;- nz_height %&gt;%\n  slice_max(n = 1, order_by = elevation)\n\ncanterbury_centroid = st_centroid(canterbury)\n\nst_distance(nz_highest, canterbury_centroid)\n\nNote: this function returns distances with units (yay!) and as a matrix, meaning we could find the distance between many locations at once."
  },
  {
    "objectID": "course-materials/labs/week3.html#simplification",
    "href": "course-materials/labs/week3.html#simplification",
    "title": "Week 3: Lab",
    "section": "Simplification",
    "text": "Simplification\nSimplification generalizes vector data (polygons and lines) to assist with plotting and reducing the amount of memory, disk space, and network bandwidth to handle a dataset.\nLet’s try simplifying the US states using the Douglas-Peucker algorithm.\nGEOS assumes a projected CRS, so we first need to project the data, in this case into the US National Atlas Equal Area (EPSG = 2163):\n\nus_states2163 &lt;- st_transform(us_states, \"EPSG:2163\")\nus_states2163 &lt;- us_states2163\n\nus_states_simp1 &lt;- st_simplify(us_states2163, dTolerance = 100000)  # 100 km\n\ntm_shape(us_states_simp1) +\n  tm_polygons()\n\n To preserve the states’ topology let’s use a simplify function from rmapshaper which uses Visalingam’s algorithm.\n\nlibrary(rmapshaper)\n\n# proportion of points to retain (0-1; default 0.05)\nus_states_simp2 &lt;- rmapshaper::ms_simplify(us_states2163, keep = 0.01,\n                                          keep_shapes = TRUE)\n\ntm_shape(us_states_simp2) +\n  tm_polygons()\n\n Instead of simplifying, we could try smoothing using Gaussian kernel regression.\n\nus_states_simp3 &lt;- smoothr::smooth(us_states2163, method = 'ksmooth', smoothness = 6)\n\ntm_shape(us_states_simp3) +\n  tm_polygons()"
  },
  {
    "objectID": "course-materials/labs/week4.html",
    "href": "course-materials/labs/week4.html",
    "title": "Week 4: Lab",
    "section": "",
    "text": "In this lab, we’ll explore the basics of working with raster data, including attribute, spatial, and geometry operations. This lab follows chapters 3, 4, and 5 of Geocomputation with R by Robin Lovelace."
  },
  {
    "objectID": "course-materials/labs/week4.html#set-up",
    "href": "course-materials/labs/week4.html#set-up",
    "title": "Week 4: Lab",
    "section": "Set Up",
    "text": "Set Up\n\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)\nlibrary(spDataLarge)\nlibrary(tmap)\nlibrary(geodata)"
  },
  {
    "objectID": "course-materials/labs/week4.html#manipulating-raster-objects",
    "href": "course-materials/labs/week4.html#manipulating-raster-objects",
    "title": "Week 4: Lab",
    "section": "Manipulating Raster Objects",
    "text": "Manipulating Raster Objects\nRaster data represents continuous surfaces, as opposed to the discrete features represented in the vector data model. Here we’ll learn how to create raster data objects from scratch and how to do basic data manipulations.\nLet’s create a SpatRaster object using a digitial elevation model for Zion National Park.\n\n# Set file path\nraster_filepath &lt;- system.file(\"raster/srtm.tif\", package = \"spDataLarge\") \n\n# Create raster object\nmy_rast &lt;- rast(raster_filepath)\n\n# Test class of raster object\nclass(my_rast)\n\n# Gives summary information\nmy_rast\n\nplot(my_rast)\n\nWe can also create rasters from scratch using the rast() function. Here we create 36 cells centerd around (0,0). By default the CRS is set to WGS84, but we could change this with the crs argument.\nBecause we are working in WGS84, the resolution is in units of degrees. rast() fills the values of the cells row-wise starting in the upper left corner.\n\nnew_raster &lt;- rast(nrows = 6, ncols = 6, resolution = 0.5,\n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\n\ntm_shape(new_raster) +\n  tm_raster()\n\nThe SpatRaster class can also handle multiple layers.\n\nmulti_raster_file &lt;- system.file(\n  \"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast &lt;- rast(multi_raster_file)\nmulti_rast\n\nnlyr(multi_rast) # test number of layers in raster object\n\nWe can subset layers using either the layer number or name:\n\nmulti_rast3 &lt;- subset(multi_rast, 3)\nmulti_rast4 &lt;- subset(multi_rast, \"landsat_4\")\n\nWe can combine SpatRaster objects into one, using c():\n\nmulti_rast34 &lt;- c(multi_rast3, multi_rast4)\n\nLet’s create an example raster for elevation:\n\nelev &lt;- rast(nrows = 6, ncols = 6, resolution = 0.5,\n            xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n            vals = 1:36)\n\nplot(elev)\n\nRasters can also hold categorical data. Let’s create an example raster for soil types:\n\ngrain_order &lt;- c(\"clay\", \"silt\", \"sand\") # set soil types\ngrain_char &lt;- sample(grain_order, 36, replace = TRUE) # randomly create character string of soil types\ngrain_fact &lt;- factor(grain_char, levels = grain_order) # convert to factors\n\ngrain &lt;- rast(nrows = 6, ncols = 6, resolution = 0.5,\n             xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n             vals = grain_fact)\n\nplot(grain)"
  },
  {
    "objectID": "course-materials/labs/week4.html#raster-subsetting",
    "href": "course-materials/labs/week4.html#raster-subsetting",
    "title": "Week 4: Lab",
    "section": "Raster Subsetting",
    "text": "Raster Subsetting\nWe can index rasters using, row-column indexing, cell IDs, coordinates, other spatial objects.\n\n# row 1, column 1\nelev[1, 1]\n\n# cell ID 1\nelev[1]\n\nIf we had a two layered raster, subsetting would return the values in both layers.\n\ntwo_layers &lt;- c(grain, elev)\ntwo_layers[1]\n\nWe can also modify/overwrite cell values.\n\nelev[1, 1] &lt;- 0\nelev[]\n\nReplacing values in multi-layer rasters requires a matrix with as many columns as layers and rows as replaceable cells.\n\ntwo_layers[1] &lt;- cbind(c(1), c(4))\ntwo_layers[]"
  },
  {
    "objectID": "course-materials/labs/week4.html#summarizing-raster-objects",
    "href": "course-materials/labs/week4.html#summarizing-raster-objects",
    "title": "Week 4: Lab",
    "section": "Summarizing Raster Objects",
    "text": "Summarizing Raster Objects\nWe can get info on raster values just by typing the name or using the summary function.\n\nelev\nsummary(elev)\n\nWe can get global summaries, such as standard deviation.\n\nglobal(elev, sd)\n\nOr we can use freq() to get the counts with categories.\n\nfreq(grain)\n\nhist(elev)"
  },
  {
    "objectID": "course-materials/labs/week4.html#spatial-subsetting",
    "href": "course-materials/labs/week4.html#spatial-subsetting",
    "title": "Week 4: Lab",
    "section": "Spatial Subsetting",
    "text": "Spatial Subsetting\nWe can move from subsetting based on specific cell IDs to extract info based on spatial objects.\nTo use coordinates for subsetting, we can “translate” coordinates into a cell ID with the terra function cellFromXY() or terra::extract().\n\nid &lt;- cellFromXY(elev, xy = matrix(c(0.1, 0.1), ncol = 2))\nelev[id]\n# the same as\nterra::extract(elev, matrix(c(0.1, 0.1), ncol = 2))\n\nRaster objects can also subset with another raster object. Here we extract the values of our elevation raster that fall within the extent of a masking raster.\n\nclip &lt;- rast(xmin = 0.9, xmax = 1.8, ymin = -0.45, ymax = 0.45,\n            resolution = 0.3, vals = rep(1, 9))\n\nelev[clip]\n\n# we can also use extract\nterra::extract(elev, ext(clip))\n\nIn the previous example, we just got the values back. In some cases, we might want the output to be the raster cells themselves.\nWe can do this use the “[” operator and setting “drop = FALSE”.\nThis example returns the first 2 cells of the first row of the “elev” raster.\n\nelev[1:2, drop = FALSE]\n\nAnother common use of spatial subsetting is when we use one raster with the same extent and resolution to mask the another. In this case, the masking raster needs to be composed of logicals or NAs.\n\n# create raster mask of the same resolution and extent\nrmask &lt;- elev \n# randomly replace values with NA and TRUE to use as a mask\nvalues(rmask) &lt;- sample(c(NA, TRUE), 36, replace = TRUE) \n\n# spatial subsetting\nelev[rmask, drop = FALSE]   # with [ operator\nmask(elev, rmask)           # with mask()\n\nWe can also use a similar approach to replace values that we suspect are incorrect.\n\nelev[elev &lt; 20] = NA"
  },
  {
    "objectID": "course-materials/labs/week4.html#map-algebra",
    "href": "course-materials/labs/week4.html#map-algebra",
    "title": "Week 4: Lab",
    "section": "Map Algebra",
    "text": "Map Algebra\nHere we define map algebra as the set of operations that modify or summarize raster cell values with reference to surrounding cells, zones, or statistical functions that apply to every cell.\n\nLocal Operations\nLocal operations are computed on each cell individually. We can use oridinary arithemetic or logical statements.\n\nelev + elev\nelev^2\nlog(elev)\nelev &gt; 5\n\nWe can also classify intervals of values into groups. For example, we could classify a DEM into low, middle, and high elevation cells:\n\nFirst, we need to construct a reclassification matrix:\n\nThe first column corresponds to the lower end of the class\nThe second column corresponds to the upper end of the class\nThe third column corresponds to the new value for the specified ranges in columns 1 and 2\n\n\n\nrcl &lt;- matrix(c(0, 12, 1, 12, 24, 2, 24, 36, 3), ncol = 3, byrow = TRUE)\nrcl\n\n# We then use this matrix to reclassify our elevation matrix\nrecl &lt;- classify(elev, rcl = rcl)\nrecl\n\nFor more efficient processing, we can use a set of map algebra functions:\n\napp() applies a function to each cell of a raster to summarize the values of multiple layers into one layer\ntapp() is an extension of app() that allows us to apply on operation on a subset of layers\nlapp() allows us to apply a function to each cell using layers as arguments\n\nWe can use the lapp()function to compute the Normalized Difference Vegetation Index (NDVI).\nLet’s calculate NDVI for Zion National Park using multispectral satellite data.\n\nmulti_raster_file &lt;- system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast &lt;- rast(multi_raster_file)\n\nWe need to define a function to calculate NDVI.\n\nndvi_fun &lt;- function(nir, red){\n  (nir - red) / (nir + red)\n}\n\nSo now we can use lapp() to calculate NDVI in each raster cell. To do so, we just need the NIR and red bands.\n\nndvi_rast &lt;- lapp(multi_rast[[c(4, 3)]], fun = ndvi_fun)\n\ntm_shape(ndvi_rast) +\n  tm_raster()\n\n\n\nFocal Operations\nLocal operations operate on one cell, though from multiple layers. Focal operations take into account a central (focal) cell and its neighbors. The neighborhood (or kernel, moving window, filter) can take any size or shape. A focal operation applies an aggregation function to all cells in the neighborhood and updates the value of the central cell before moving on to the next central cell\nWe can use the focal() function to perform spatial filtering. We define the size, shape, and weights of the moving window using a matrix. Here we find the minimum.\n\nelev &lt;- rast(system.file(\"raster/elev.tif\", package = \"spData\"))\n\nr_focal &lt;- focal(elev, w = matrix(1, nrow = 3, ncol = 3), fun = min)\n\nplot(elev)\nplot(r_focal)\n\n\n\nZonal Operations\nSimilar to focal operations, zonal operations apply an aggregation function to multiple cells. However, instead of applying operations to neighbors, zonal operations aggregate based on “zones”. Zones can are defined using a categorical raster and do not necessarily have to be neighbors\nFor example, we could find the average elevation for different soil grain sizes.\n\nzonal(elev, grain, fun = \"mean\")"
  },
  {
    "objectID": "course-materials/labs/week4.html#merging-rasters",
    "href": "course-materials/labs/week4.html#merging-rasters",
    "title": "Week 4: Lab",
    "section": "Merging Rasters",
    "text": "Merging Rasters\nIn some cases, data for a region will be stored in multiple, contiguous files. To use them as a single raster, we need to merge them.\nIn this example, we download elevation data for Austria and Switzerland and merge the two rasters into one.\n\naut &lt;- geodata::elevation_30s(country = \"AUT\", path = tempdir())\nch &lt;- geodata::elevation_30s(country = \"CHE\", path = tempdir())\naut_ch &lt;- merge(aut, ch)"
  },
  {
    "objectID": "course-materials/labs/week4.html#geometric-operations",
    "href": "course-materials/labs/week4.html#geometric-operations",
    "title": "Week 4: Lab",
    "section": "Geometric Operations",
    "text": "Geometric Operations\nWhen merging or performing map algebra, rasters need to match in their resolution, projection, origin, and/or extent\nIn the simplest case, two images differ only in their extent. Let’s start by increasing the extent of a elevation raster.\n\nelev &lt;- rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nelev_2 &lt;- extend(elev, c(1, 2)) # add one row and two columns\n\nplot(elev)\nplot(elev_2)\n\nPerforming algebraic operations on objects with different extents doesn’t work.\n\nelev + elev_2\n\nWe can align the extent of the 2 rasters using the extend() function. Here we extend the elev object to the extent of elev_2 by adding NAs.\n\nelev_4 &lt;- extend(elev, elev_2)\n\nthe origin function returns the coordinates of the cell corner closes to the coordinates (0,0). We can also manually change the origin.\n\norigin(elev_4)\norigin(elev_4) &lt;- c(0.25, 0.25)\norigin(elev_4)"
  },
  {
    "objectID": "course-materials/labs/week4.html#aggregation-and-disaggregation",
    "href": "course-materials/labs/week4.html#aggregation-and-disaggregation",
    "title": "Week 4: Lab",
    "section": "Aggregation and Disaggregation",
    "text": "Aggregation and Disaggregation\nFaster datasets can also differ in their resolution to match resolutions we can decrease the resolution by aggregating or increase the resolution by disaggregating.\nLet’s start by changing the resolution of a DEM by a factor of 5, by taking the mean.\n\ndem &lt;- rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\ndem_agg &lt;-  aggregate(dem, fact = 5, fun = mean)\n\nplot(dem)\nplot(dem_agg)\n\nWe have some choices when increasing the resolution. Here, we try the bilinear method.\n\ndem_disagg &lt;- disagg(dem_agg, fact = 5, method = \"bilinear\")\nidentical(dem, dem_disagg)\n\nplot(dem_disagg)"
  },
  {
    "objectID": "course-materials/labs/week4.html#resampling",
    "href": "course-materials/labs/week4.html#resampling",
    "title": "Week 4: Lab",
    "section": "Resampling",
    "text": "Resampling\nAggregation/disaggregation work when both rasters have the same origins.\nBut what do we do in the case where we have two or more rasters with different origins and resolutions? Resampling computes values for new pixel locations based on custom resolutions and origins.\nIn most cases, the target raster would be an object you are already working with, but here we define a target raster.\n\ntarget_rast &lt;- rast(xmin = 794600, xmax = 798200,\n                   ymin = 8931800, ymax = 8935400,\n                   resolution = 150, crs = \"EPSG:32717\")\n\ndem_resampl &lt;- resample(dem, y = target_rast, method = \"bilinear\")\n\nplot(dem)\nplot(dem_resampl)"
  },
  {
    "objectID": "course-materials/labs/week9.html",
    "href": "course-materials/labs/week9.html",
    "title": "Week 9: Lab",
    "section": "",
    "text": "Monitoring the distribution and change in land cover types can help us understand the impacts of phenomena like climate change, natural disasters, deforestation, and urbanization. Determining land cover types over large areas is a major application of remote sensing because we are able to distinguish different materials based on their spectral reflectance.\nClassifying remotely sensed imagery into land cover classes enables us to understand the distribution and change in land cover types over large areas.\nThere are many approaches for performing land cover classification:\nThis lab is based on a materials developed by Chris Kibler."
  },
  {
    "objectID": "course-materials/labs/week9.html#task",
    "href": "course-materials/labs/week9.html#task",
    "title": "Week 9: Lab",
    "section": "Task",
    "text": "Task\nIn this lab, we are using a form of supervised classification, a decision tree classifier.\nDecision trees classify pixels using a series of conditions based on values in spectral bands. These conditions (or decisions) are developed based on training data.\nIn this lab, we will create a land cover classification for southern Santa Barbara County based on multi-spectral imagery and data on the location of 4 land cover types: (1) green vegetation; (2) dry grass or soil; (3) urban; and (4) water.\nOur goals in this lab are:\n\nLoad and process Landsat scene\nCrop and mask Landsat data to study area\nExtract spectral data at training sites\nTrain and apply decision tree classifier\nPlot results"
  },
  {
    "objectID": "course-materials/labs/week9.html#data",
    "href": "course-materials/labs/week9.html#data",
    "title": "Week 9: Lab",
    "section": "Data",
    "text": "Data\nLandsat 5 Thematic Mapper\n\nLandsat 5\n1 scene from September 25, 2007\n\nBands: 1, 2, 3, 4, 5, 7\nCollection 2 surface reflectance product\n\nStudy area and training data\n\nPolygon representing southern Santa Barbara county\nPolygons representing training sites\n\ntype: character string with land cover type"
  },
  {
    "objectID": "course-materials/labs/week9.html#set-up",
    "href": "course-materials/labs/week9.html#set-up",
    "title": "Week 9: Lab",
    "section": "Set Up",
    "text": "Set Up\nWe’ll be working with vector and raster data, so will need both sf and terra. To train our classification algorithm and plot the results, we’ll use the rpart and rpart.plot packages.\nSet your working directory to the folder that holds the data for this lab.\n- Note: my filepaths may look different than yours!\nLet’s load all necessary packages:\n\nlibrary(sf)\nlibrary(terra)\nlibrary(here)\nlibrary(dplyr)\nlibrary(rpart)\nlibrary(rpart.plot)\nlibrary(tmap)"
  },
  {
    "objectID": "course-materials/labs/week9.html#load-landsat-data",
    "href": "course-materials/labs/week9.html#load-landsat-data",
    "title": "Week 9: Lab",
    "section": "Load Landsat Data",
    "text": "Load Landsat Data\nLet’s create a raster stack. Each file name ends with the band number (e.g. B1.tif).\n\nNotice that we are missing a file for band 6\nBand 6 corresponds to thermal data, which we will not be working with for this lab\n\nTo create a raster stack, we will create a list of the files that we would like to work with and read them all in at once using the rast function. We’ll then update the names of the layers to match the spectral bands and plot a true color image to see what we’re working with.\n\n# list files for each band, including the full file path\nfilelist &lt;- list.files(here::here(\"course-materials\", \"data\", \"week9\", \"landsat-data\"), full.names = TRUE)\n\n# read in and store as a raster stack\nlandsat_20070925 &lt;- rast(filelist)\n\n# update layer names to match band\nnames(landsat_20070925) &lt;- c(\"blue\", \"green\", \"red\", \"NIR\", \"SWIR1\", \"SWIR2\")\n\n# plot true color image\nplotRGB(landsat_20070925, r = 3, g = 2, b = 1, stretch = \"lin\")"
  },
  {
    "objectID": "course-materials/labs/week9.html#load-study-area",
    "href": "course-materials/labs/week9.html#load-study-area",
    "title": "Week 9: Lab",
    "section": "Load Study Area",
    "text": "Load Study Area\nWe want to constrain our analysis to the southern portion of the county where we have training data, so we’ll read in a file that defines the area we would like to study.\n\n# read in shapefile for southern portion of SB county\nSB_county_south &lt;- st_read(here::here(\"course-materials\", \"data\", \"week9\", \"SB_county_south.shp\"))\n\n# project to match the Landsat data\nSB_county_south &lt;- st_transform(SB_county_south, crs = crs(landsat_20070925))"
  },
  {
    "objectID": "course-materials/labs/week9.html#crop-and-mask-landsat-data-to-study-area",
    "href": "course-materials/labs/week9.html#crop-and-mask-landsat-data-to-study-area",
    "title": "Week 9: Lab",
    "section": "Crop and Mask Landsat Data to Study Area",
    "text": "Crop and Mask Landsat Data to Study Area\nNow, we can crop and mask the Landsat data to our study area.\n\nWhy? This reduces the amount of data we’ll be working with and therefore saves computational time\nBonus: We can also remove any objects we’re no longer working with to save space\n\n\n# crop Landsat scene to the extent of the SB county shapefile\nlandsat_cropped &lt;- crop(landsat_20070925, SB_county_south)\n\n# mask the raster to southern portion of SB county\nlandsat_masked &lt;- mask(landsat_cropped, SB_county_south)\n\n# remove unnecessary object from environment\nrm(landsat_20070925, SB_county_south, landsat_cropped)"
  },
  {
    "objectID": "course-materials/labs/week9.html#convert-landsat-values-to-reflectance",
    "href": "course-materials/labs/week9.html#convert-landsat-values-to-reflectance",
    "title": "Week 9: Lab",
    "section": "Convert Landsat Values to Reflectance",
    "text": "Convert Landsat Values to Reflectance\nNow we need to convert the values in our raster stack to correspond to reflectance values. To do so, we need to remove erroneous values and apply any scaling factors to convert to reflectance.\nIn this case, we are working with Landsat Collection 2.\n\nThe valid range of pixel values for this collection goes from 7,273 to 43,636…\n\nwith a multiplicative scale factor of 0.0000275\nwith an additive scale factor of -0.2\n\n\nLet’s reclassify any erroneous values as NA and update the values for each pixel based on the scaling factors. Now the pixel values should range from 0-100%!\n\n# reclassify erroneous values as NA\nrcl &lt;- matrix(c(-Inf, 7273, NA,\n                 43636, Inf, NA), ncol = 3, byrow = TRUE)\n\nlandsat &lt;- classify(landsat_masked, rcl = rcl)\n\n# adjust values based on scaling factor\nlandsat &lt;- (landsat * 0.0000275 - 0.2) * 100\n\n# plot true color image to check results\nplotRGB(landsat, r = 3, g = 2, b = 1, stretch = \"lin\")\n\n# check values are 0 - 100\nsummary(landsat)"
  },
  {
    "objectID": "course-materials/labs/week9.html#classify-image",
    "href": "course-materials/labs/week9.html#classify-image",
    "title": "Week 9: Lab",
    "section": "Classify Image",
    "text": "Classify Image\nLet’s begin by extracting reflectance values for training data!\n\nWe will load the shapefile identifying different locations within our study area as containing one of our 4 land cover types.\nWe can then extract the spectral values at each site to create a data frame that relates land cover types to their spectral reflectance.\n\n\n# read in and transform training data\ntraining_data &lt;- st_read(here::here(\"course-materials\", \"data\", \"week9\", \"trainingdata.shp\")) %&gt;%\n  st_transform(., crs = crs(landsat))\n\n# extract reflectance values at training sites\ntraining_data_values &lt;- extract(landsat, training_data, df = TRUE)\n\n# convert training data to data frame\ntraining_data_attributes &lt;- training_data %&gt;%\n  st_drop_geometry()\n\n# join training data attributes and extracted reflectance values\nSB_training_data &lt;- left_join(training_data_values, training_data_attributes,\n                              by = c(\"ID\" = \"id\")) %&gt;%\n  mutate(type = as.factor(type)) # convert landcover type to factor\n\nNext, let’s train the decision tree classifier!\nTo train our decision tree, we first need to establish our model formula (i.e. what our response and predictor variables are).\n\nThe rpart function implements the CART algorithm\nThe rpart function needs to know the model formula and training data you would like to use\nBecause we are performing a classification, we set method = \"class\"\nWe also set na.action = na.omit to remove any pixels with NAs from the analysis.\n\nTo understand how our decision tree will classify pixels, we can plot the results!\n\nNote: The decision tree is comprised of a hierarchy of binary decisions. Each decision rule has 2 outcomes based on a conditional statement pertaining to values in each spectral band.\n\n\n# establish model formula\nSB_formula &lt;- type ~ red + green + blue + NIR + SWIR1 + SWIR2\n\n# train decision tree\nSB_decision_tree &lt;- rpart(formula = SB_formula,\n                          data = SB_training_data,\n                          method = \"class\",\n                          na.action = na.omit)\n\n# plot decision tree\nprp(SB_decision_tree)\n\n…and apply the decision tree!\nThe terra package includes a predict() function that allows us to apply a model to our data. In order for this to work properly, the names of the layers need to match the column names of the predictors we used to train our decision tree. The predict() function will return a raster layer with integer values. These integer values correspond to the factor levels in the training data. To figure out what category each integer corresponds to, we can inspect the levels of our training data.\n\n# classify image based on decision tree\nSB_classification &lt;- predict(landsat, SB_decision_tree, type = \"class\", na.rm = TRUE)\n\n# inspect level to understand the order of classes in prediction\nlevels(SB_training_data$type)"
  },
  {
    "objectID": "course-materials/labs/week9.html#plot-results",
    "href": "course-materials/labs/week9.html#plot-results",
    "title": "Week 9: Lab",
    "section": "Plot Results",
    "text": "Plot Results\nNow we can plot the results and check out our land cover map!\n\n# plot results\ntm_shape(SB_classification) +\n  tm_raster(col.scale = tm_scale_categorical(values = c(\"#8DB580\", \"#F2DDA4\", \"#7E8987\", \"#6A8EAE\")),\n            col.legend = tm_legend(labels = c(\"green vegetation\", \"soil/dead grass\", \"urban\", \"water\"),\n                                   title = \"Landcover type\")) +\n  tm_layout(legend.position = c(\"left\", \"bottom\"))"
  },
  {
    "objectID": "course-materials/week1.html",
    "href": "course-materials/week1.html",
    "title": "Intro to EDS 223 and map making",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nWelcome to EDS 223, why spatial?, and fundamentals of good maps\n\n\n Lab\nMaking maps in R with tmap\n\n\n Discussion\nMap making practice"
  },
  {
    "objectID": "course-materials/week1.html#class-materials",
    "href": "course-materials/week1.html#class-materials",
    "title": "Intro to EDS 223 and map making",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nWelcome to EDS 223, why spatial?, and fundamentals of good maps\n\n\n Lab\nMaking maps in R with tmap\n\n\n Discussion\nMap making practice"
  },
  {
    "objectID": "course-materials/week1.html#assignment-reminders",
    "href": "course-materials/week1.html#assignment-reminders",
    "title": "Intro to EDS 223 and map making",
    "section": " Assignment Reminders",
    "text": "Assignment Reminders\n\n\n\nAssignment Type\nAssignment Title\nDate Assigned\nDate Due\n\n\n\n\nEOC\nEnd-of-class survey (week 1)\nMon 01/08/2024\nMon 01/08/2024, 11:55pm PT\n\n\nSR\nPre-course reflection (SR #1)\nMon 01/08/2024\nSat 01/13/2024, 11:59pm PT\n\n\nHW\nHomework Assignment #1\nMon 01/08/2024\nSat 01/20/2024, 11:59pm PT"
  },
  {
    "objectID": "course-materials/week1.html#background-reading",
    "href": "course-materials/week1.html#background-reading",
    "title": "Intro to EDS 223 and map making",
    "section": " Background Reading",
    "text": "Background Reading\n\nGeocomputation with R, Chapter 9\nGIS Fundamentals, Chapter 2\nGIS Fundamentals, Chapter 3\nA Gentle Introduction to GIS, Chapter 8\nGeographic vs projected coordinate systems (Esri)"
  },
  {
    "objectID": "course-materials/week1.html#technical-background",
    "href": "course-materials/week1.html#technical-background",
    "title": "Intro to EDS 223 and map making",
    "section": " Technical Background",
    "text": "Technical Background\n\ntmap: thematic maps in R documentation\ntmap overview\nCreating thematic maps in R"
  },
  {
    "objectID": "course-materials/week1.html#additional-resources",
    "href": "course-materials/week1.html#additional-resources",
    "title": "Intro to EDS 223 and map making",
    "section": " Additional Resources",
    "text": "Additional Resources\n\nJohn Snow: A Legacy of Disease Detectives (CDC)\nHow the north ended up on top of the map (Al Jazeera)\nWhy maps point North on top? (Geospatial World)\nWhy all world maps are wrong (Vox)"
  },
  {
    "objectID": "course-materials/week2.html",
    "href": "course-materials/week2.html",
    "title": "Intro to spatial data models",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nIntro to spatial/vector data models\n\n\n Lab\nSpatial operations with vector data\n\n\n Discussion\nWorking with multiple vector types"
  },
  {
    "objectID": "course-materials/week2.html#class-materials",
    "href": "course-materials/week2.html#class-materials",
    "title": "Intro to spatial data models",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nIntro to spatial/vector data models\n\n\n Lab\nSpatial operations with vector data\n\n\n Discussion\nWorking with multiple vector types"
  },
  {
    "objectID": "course-materials/week2.html#assignment-reminders",
    "href": "course-materials/week2.html#assignment-reminders",
    "title": "Intro to spatial data models",
    "section": " Assignment Reminders",
    "text": "Assignment Reminders\n\n\n\nAssignment Type\nAssignment Title\nDate Assigned\nDate Due\n\n\n\n\nEOC\nEnd-of-class survey (week 1)\nMon 01/08/2024\nMon 01/08/2024, 11:55pm PT\n\n\nSR\nPre-course reflection (SR #1)\nMon 01/08/2024\nSat 01/13/2024, 11:59pm PT\n\n\nHW\nHomework Assignment #1\nMon 01/08/2024\nSat 01/20/2024, 11:59pm PT"
  },
  {
    "objectID": "course-materials/week2.html#background-reading",
    "href": "course-materials/week2.html#background-reading",
    "title": "Intro to spatial data models",
    "section": " Background Reading",
    "text": "Background Reading\n\nGIS Fundamentals, Chapter 2 Part 2\nGeocomputation with R, Chapter 2\nGeocomputation with R, Chapter 3\nGeocomputation with R, Chapter 7"
  },
  {
    "objectID": "course-materials/week2.html#additional-resources",
    "href": "course-materials/week2.html#additional-resources",
    "title": "Intro to spatial data models",
    "section": " Additional Resources",
    "text": "Additional Resources\n\nsf overview\nsf cheatsheet\nIntroduction to sf and stars"
  },
  {
    "objectID": "course-materials/week4.html",
    "href": "course-materials/week4.html",
    "title": "Raster spatial and geometry operations",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nIntro to raster data\n\n\n Lab\nBasics of raster operations with terra\n\n\n Discussion\nPractice with raster manipulations"
  },
  {
    "objectID": "course-materials/week4.html#class-materials",
    "href": "course-materials/week4.html#class-materials",
    "title": "Raster spatial and geometry operations",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nIntro to raster data\n\n\n Lab\nBasics of raster operations with terra\n\n\n Discussion\nPractice with raster manipulations"
  },
  {
    "objectID": "course-materials/week4.html#assignment-reminders",
    "href": "course-materials/week4.html#assignment-reminders",
    "title": "Raster spatial and geometry operations",
    "section": " Assignment Reminders",
    "text": "Assignment Reminders\n\n\n\nAssignment Type\nAssignment Title\nDate Assigned\nDate Due\n\n\n\n\nEOC\nEnd-of-class survey (week 1)\nMon 01/08/2024\nMon 01/08/2024, 11:55pm PT\n\n\nSR\nSelf reflection (SR #1)\nMon 01/08/2024\nSat 01/13/2024, 11:59pm PT\n\n\nHW\nHomework Assignment #1\nMon 01/08/2024\nSat 01/20/2024, 11:59pm PT"
  },
  {
    "objectID": "course-materials/week4.html#background-reading",
    "href": "course-materials/week4.html#background-reading",
    "title": "Raster spatial and geometry operations",
    "section": " Background Reading",
    "text": "Background Reading\n\nGeocomputation with R, Chapter 3\nGeocomputation with R, Chapter 4\nGeocomputation with R, Chapter 5"
  },
  {
    "objectID": "course-materials/week6.html",
    "href": "course-materials/week6.html",
    "title": "Remote sensing data collection",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nResolutions: spatial, temporal, spectral, radiometric\n\n\n Lab\ndescription\n\n\n Discussion\ndescription"
  },
  {
    "objectID": "course-materials/week6.html#class-materials",
    "href": "course-materials/week6.html#class-materials",
    "title": "Remote sensing data collection",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nResolutions: spatial, temporal, spectral, radiometric\n\n\n Lab\ndescription\n\n\n Discussion\ndescription"
  },
  {
    "objectID": "course-materials/week6.html#assignment-reminders",
    "href": "course-materials/week6.html#assignment-reminders",
    "title": "Remote sensing data collection",
    "section": " Assignment Reminders",
    "text": "Assignment Reminders\n\n\n\nAssignment Type\nAssignment Title\nDate Assigned\nDate Due\n\n\n\n\nEOC\nEnd-of-class survey (week 1)\nMon 01/08/2024\nMon 01/08/2024, 11:55pm PT\n\n\nSR\nSelf reflection (SR #1)\nMon 01/08/2024\nSat 01/13/2024, 11:59pm PT\n\n\nHW\nHomework Assignment #1\nMon 01/08/2024\nSat 01/20/2024, 11:59pm PT"
  },
  {
    "objectID": "course-materials/week6.html#background-reading",
    "href": "course-materials/week6.html#background-reading",
    "title": "Remote sensing data collection",
    "section": " Background Reading",
    "text": "Background Reading\n\nRemote Sensing of the Environment, Chapter 1\nRemote Sensing of the Environment, Chapter 2\nHow to Interpret a False-Color Satellite Image"
  },
  {
    "objectID": "course-materials/week6.html#additional-resources",
    "href": "course-materials/week6.html#additional-resources",
    "title": "Remote sensing data collection",
    "section": " Additional Resources",
    "text": "Additional Resources\n\nHow raster functions map to stars functions\nSpatiotemporal raster data handling with stars\nA comparison of terra and stars packages"
  },
  {
    "objectID": "course-materials/week9.html",
    "href": "course-materials/week9.html",
    "title": "Week 9: Land Cover Classification",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nImage classifiction: unsupervised and supervised approaches\n\n\n Lab\nLandcover classification with random forests\n\n\n Discussion\ndescription"
  },
  {
    "objectID": "course-materials/week9.html#class-materials",
    "href": "course-materials/week9.html#class-materials",
    "title": "Week 9: Land Cover Classification",
    "section": "",
    "text": "Session\nMaterials\n\n\n\n\n Lecture\nImage classifiction: unsupervised and supervised approaches\n\n\n Lab\nLandcover classification with random forests\n\n\n Discussion\ndescription"
  },
  {
    "objectID": "course-materials/week9.html#assignment-reminders",
    "href": "course-materials/week9.html#assignment-reminders",
    "title": "Week 9: Land Cover Classification",
    "section": " Assignment Reminders",
    "text": "Assignment Reminders\n\n\n\nAssignment Type\nAssignment Title\nDate Assigned\nDate Due\n\n\n\n\nEOC\nEnd-of-class survey (week 1)\nMon 01/08/2024\nMon 01/08/2024, 11:55pm PT\n\n\nSR\nSelf reflection (SR #1)\nMon 01/08/2024\nSat 01/13/2024, 11:59pm PT\n\n\nHW\nHomework Assignment #1\nMon 01/08/2024\nSat 01/20/2024, 11:59pm PT"
  },
  {
    "objectID": "course-materials/labs/week1.html#layers",
    "href": "course-materials/labs/week1.html#layers",
    "title": "Week 1 Lab",
    "section": "4. Layers",
    "text": "4. Layers\nAgain following the syntax of ggplot2 which uses layers to plot data (e.g. geom_point()), tmap also uses layers! We’ve already used layers in our previous examples (e.g. tm_borders()), but now we’ll dig into them in more detail. All possible layer types can be found in the table below:\n\n\n\nMap layers.\n\n\nFunction\nElement\nGeometry\n\n\n\n\nBasic functions\n\n\ntm_polygons()\npolygons (borders and fill)\npolygons\n\n\ntm_symbols()\nsymbols\npoints, polygons, and lines\n\n\ntm_lines()\nlines\nlines\n\n\ntm_raster()\nraster\nraster\n\n\ntm_text()\ntext\npoints, polygons, and lines\n\n\ntm_basemap()\ntile\n\n\n\ntm_tiles()\ntile\n\n\n\nDerived functions\n\n\ntm_borders()\npolygons (borders)\npolygons\n\n\ntm_fill()\npolygons (fill)\npolygons\n\n\ntm_bubbles()\nbubbles\npoints, polygons, and lines\n\n\ntm_dots()\ndots\npoints, polygons, and lines\n\n\ntm_markers()\nmarker symbols\npoints, polygons, and lines\n\n\ntm_square()\nsquares\npoints, polygons, and lines\n\n\ntm_iso()\nlines with text labels\nlines\n\n\ntm_rgb()/tm_rgba()\nraster (RGB image)\nraster\n\n\n\n\n\n\n\nLet’s practice by using a dataset that contains a polygon representing the perimeter of Easter Island.\n\nei_borders &lt;- read_sf(here(\"data\", \"easter_island\", \"ei_border.gpkg\"))\n\n\nPolygons\nThe main function to visualize polygons is tm_polygons(). By default, it plots the internal area of the polygon in light grey and the polygon borders in slightly darker grey.\n\ntm_shape(world_vector) +\n  tm_polygons()\n\n\n\n\n\n\n\n\nWe modify the colors useing the col and border.col arguments and other arguments borrowed from ggplot2.\n\ntm_shape(world_vector) +\n  tm_polygons(col = \"lightblue\",\n              border.col = \"black\",\n              lwd = 0.5,\n              lty = \"dashed\")\n\n\n\n\n\n\n\n\nBut, you may have noticed in the previous table that tm_polygons isn’t the only function we can use to plot polygon data. In fact, tm_polygons is a combination of two separate functions - tm_fill() and tm_borders().\nThe tm_borders() function plots just the borders and the tm_fill() function fills polygons with a fixed color or a color palette representing a selected variable.\n\n# plot just borders\n\ntm_shape(world_vector) +\n  tm_borders(col = \"red\")\n\n\n\n\n\n\n\n\n\n# fill polygons with fixed color\n\ntm_shape(world_vector) +\n  tm_fill(col = \"lightblue\")\n\n\n\n\n\n\n\n\n\n# fill polygons with a color palette representing a variable\n\ntm_shape(world_vector) +\n  tm_fill(\"CO2_emissions\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSyntax differences\n\n\n\nNote that to change the border color in tm_polygons() we used the border.col argument, but in tm_borders() we used the col argument. This is necessary in tm_polygons() to differentiate between the settings for the polyons fill and borders.\n\n\n\n\nSymbols\nSymbols are a very flexible layer type. They typically represent point data, but can also be used for lines and polygons (in this case located at the centroid of each feature). Symbols are also highly flexible in how they can be visualized. They can show the values of a given variable by the color, size, and shape of the symbol.\ntm_symbols() is the main function in tmap to display and modify symbol elements. By default, this function draws a gray circle symbol with a black border for each element of an input feature.\n\ntm_shape(world_cities) +\n  tm_symbols()\n\n\n\n\n\n\n\n\ntm_symbols() has a large number of arguments to flexible adjust how elements are displayed. While this allows adjusting its results to almost any need, it also makes this function complicated. Therefore, four additional layers are implemented in tmap: tm_squares(), tm_bubbles(), tm_dots(), tm_markers(). All of them use tm_symbols(), but with different default values.\n\ntm_squares(): uses square symbols (shape = 22)\ntm_bubbles(): uses large circle symbols\ntm_dots(): uses small circle symbols (good for displaying many locations)\ntm_markers(): uses marker icons\n\n\ntm_shape(world_cities) +\n  tm_squares()\n\n\n\n\n\n\n\ntm_shape(world_cities) +\n  tm_bubbles()\n\n\n\n\n\n\n\ntm_shape(world_cities) +\n  tm_dots()"
  },
  {
    "objectID": "course-materials/labs/week1.html#visual-variables",
    "href": "course-materials/labs/week1.html#visual-variables",
    "title": "Week 1 Lab",
    "section": "5. Visual variables",
    "text": "5. Visual variables\nFollowing ggplot2 yet again, tmap uses the basic visual variables of color, size, and shape to represent data. Which variables can be applied depends on the typ of the map layer.\n\nSymbols: color, size, and shape\nLines: color and size\nPolygons: color\n\nThe type of data (quantitative or qualitative) also determines which visual variables can be used.\n\nColor: quantitative or qualitative\nSize: quantitative\nShape: qualitative\n\n\nColor\ntmap uses the many ways that colors can be specified in R:\n\nbuilt-in color names (e.g. “red”)\nhexadecimal (e.g. #00FF00)\npalettes\n\nThere are dozens of packages that contain hundreds of color palettes. The most popular are RColorBrewer and viridis. By default, tmap attempts to identify the type of the data being plotted and selects on of the built-in palettes.\ntmap offers three main ways to specify color palettes using the palette argument:\n\na vector of colors\na palette function\none of the built-in names\n\nA vector of colors can be specified by name or hexidecimal. Importantly, the number of colors provided does not need to match the number of colors in the map legend. tmap automatically interpolates new colors in the case when a smaller number of colors is provided.\n\n# vector of colors\n\ntm_shape(world_vector) +\n  tm_polygons(\"life_expectancy\", palette = c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nAnother approach is to provide the output of a palette function. When using a palette function, you can specify the number of colors to use. Below we use the viridis palette from the viridisLite package.\n\n# palette function\n\n#install.packages(\"viridisLite\")\nlibrary(viridisLite)\n\ntm_shape(world_vector) +\n  tm_polygons(\"life_expectancy\", palette = viridis(8))\n\n\n\n\n\n\n\n\nFinally, the last approach is to use the name of one of the built-in color palettes.\n\n# built-in color palette\n\ntm_shape(world_vector) +\n  tm_polygons(\"life_expectancy\", palette = \"YlGn\")\n\n\n\n\n\n\n\n\n\n\nSize\nSizes can be used for points, lines (line widths), or text to represent quantitative (numerical) variables. By default, tmap represents points, lines, or text objects as the same size. The size of objects can be changed by using the size argument.\n\ntm_shape(world_vector) +\n  tm_polygons(col = \"lightblue\") +\ntm_shape(world_cities) +\n  tm_symbols(size = \"pop2020\")"
  },
  {
    "objectID": "course-materials/labs/week1.html#layout",
    "href": "course-materials/labs/week1.html#layout",
    "title": "Week 1 Lab",
    "section": "6. Layout",
    "text": "6. Layout\nJust like in standard data visualiztions, maps have elements that need to be provided in order to interpret them correctly. Maps need to contain either a scale bar and north arrow OR grid lines or graticules. tmap provides these elements (and others) as the following additional attribute layers.\n\n\n\nAttribute layers.\n\n\nFunction\nDescription\n\n\n\n\ntm_grid()\ndraws coordinate grid lines of the coordinate system of the main shape object\n\n\ntm_graticules()\ndraws latitude and longitude graticules\n\n\ntm_scale_bar()\nadds a scale bar\n\n\ntm_compass()\nadds a compass rose\n\n\ntm_credits()\nadds a text annotation\n\n\ntm_logo()\nadds a logo\n\n\ntm_xlab()\nadds an x axis labels\n\n\ntm_ylab()\nadds an y axis labels\n\n\ntm_minimap()\nadds minimap in the view mode only\n\n\n\n\n\n\n\n\nGrid lines\nThe tmap package offers two ways to draw coordinate lines - tm_grid() and tm_graticules(). tm_grid() represents the input data’s coordinates.\n\ntm_shape(world_vector) +\n  tm_fill() +\n  tm_grid()\n\n\n\n\n\n\n\n\ntm_graticules() shows latitude and longitude lines, with degrees as units\n\ntm_shape(world_vector) +\n  tm_fill() +\n  tm_graticules()\n\n\n\n\n\n\n\n\nBoth tm_grid() and tm_graticules() can be placed above or below other map layers.\n\ntm_shape(world_vector) +\n  tm_graticules() + # graticules below tm_fill()\n  tm_fill()\n\n\n\n\n\n\n\n\n\n\nScale bar and north arrow\nA scale bar is a graphic indicator of the relation between a distance on a map and the corresponding distance in the real world. A north arrow, or a map compass or compass rose, indicates the orientation of the map. North arrows can be added to every map, but are not necessary on maps of large areas (e.g. global maps) where the orientation is obvious.\n\ntm_shape(world_vector) +\n  tm_fill() +\n  tm_scale_bar() +\n  tm_compass(position = c(\"left\", \"top\"))"
  },
  {
    "objectID": "course-materials/labs/week1.html#interactive-options",
    "href": "course-materials/labs/week1.html#interactive-options",
    "title": "Week 1 Lab",
    "section": "7. Interactive options",
    "text": "7. Interactive options\nOne of the most powerful aspects of tmap is the ease of creating interactive maps. tmap has two modes \"plot\" which creates static maps and \"view\" which creates interactive maps. It’s as easy as using the tmap_mode().\n\ntmap_mode(\"view\")\n\ntmap mode set to interactive viewing\n\ntm_shape(world_vector) +\n  tm_fill()"
  }
]